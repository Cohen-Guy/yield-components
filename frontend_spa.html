<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8" />
  <title>×“×©×‘×•×¨×“ ××¨×›×™×‘×™ ×ª×©×•××”</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root {
      --bg-main: #050816;
      --bg-panel: #101528;
      --bg-panel-soft: #151a32;
      --bg-sidebar: #050a18;
      --accent: #5dd0ff;
      --accent-soft: rgba(93,208,255,0.14);
      --accent-strong: #3ab4ff;
      --text-main: #e9eefb;
      --text-muted: #a6b2c9;
      --border-subtle: rgba(255,255,255,0.06);
      --danger: #ff7676;
      --success: #7ce38b;
      --warning: #ffc773;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1a2344 0, #050816 55%, #02030a 100%);
      color: var(--text-main);
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app-shell {
      width: 100%;
      max-width: 1440px;
      min-height: 100vh;
      display: grid;
      grid-template-columns: 220px 1fr;
      background: linear-gradient(135deg, rgba(255,255,255,0.03), rgba(3,5,20,0.98));
      border-left: 1px solid rgba(255,255,255,0.05);
      border-right: 1px solid rgba(255,255,255,0.05);
    }

    /* Sidebar */
    .sidebar {
      background: radial-gradient(circle at top, #141b3d 0, #050a18 58%);
      border-right: 1px solid rgba(255,255,255,0.08);
      padding: 18px 14px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .sidebar-logo { display: flex; align-items: center; gap: 8px; padding: 6px 4px 12px; border-bottom: 1px solid rgba(255,255,255,0.07); }
    .sidebar-logo-icon {
      width: 32px; height: 32px; border-radius: 10px;
      background: radial-gradient(circle at 30% 20%, #5dd0ff, #4a63ff);
      display: flex; align-items: center; justify-content: center; font-size: 1.1rem;
    }
    .sidebar-logo-text { display: flex; flex-direction: column; gap: 2px; }
    .sidebar-logo-title { font-size: 0.95rem; font-weight: 600; letter-spacing: 0.03em; }
    .sidebar-logo-sub { font-size: 0.7rem; color: var(--text-muted); }

    .sidebar-nav { display: flex; flex-direction: column; gap: 4px; margin-top: 6px; }
    .nav-item {
      border-radius: 999px; padding: 7px 10px; font-size: 0.86rem;
      display: flex; align-items: center; gap: 8px; color: var(--text-muted);
      cursor: pointer; border: 1px solid transparent;
      transition: background 0.15s, transform 0.08s, border-color 0.15s, color 0.15s;
    }
    .nav-item span.icon { font-size: 1rem; width: 18px; text-align: center; }
    .nav-item:hover { background: rgba(93,208,255,0.08); color: var(--text-main); border-color: rgba(93,208,255,0.4); transform: translateY(-1px); }
    .nav-item.active { background: linear-gradient(120deg, rgba(93,208,255,0.25), rgba(116,127,255,0.25)); color: #f8fbff; border-color: rgba(93,208,255,0.6); }

    .sidebar-meta {
      margin-top: auto; padding-top: 8px; border-top: 1px dashed rgba(255,255,255,0.12);
      font-size: 0.7rem; color: var(--text-muted); display: flex; flex-direction: column; gap: 4px;
    }
    .sidebar-meta span { display: flex; justify-content: space-between; }

    /* Main area */
    .main { padding: 16px 18px 18px; display: flex; flex-direction: column; gap: 12px; }

    .main-header { display: flex; align-items: center; justify-content: space-between; gap: 10px; padding: 6px 6px 8px; }
    .main-title-block { display: flex; flex-direction: column; gap: 2px; }
    .main-title { font-size: 1.4rem; letter-spacing: 0.02em; display: flex; align-items: center; gap: 6px; }
    .main-subtitle { font-size: 0.82rem; color: var(--text-muted); }

    .badge-file {
      font-size: 0.75rem; padding: 3px 8px; border-radius: 999px;
      background: rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.16); color: var(--text-muted);
    }

    .main-header-actions { display: flex; align-items: center; gap: 8px; }
    .btn-ghost {
      border-radius: 999px; border: 1px solid rgba(255,255,255,0.18);
      background: rgba(5,8,25,0.9); color: var(--text-main);
      padding: 6px 10px; font-size: 0.8rem; display: flex; align-items: center; gap: 6px;
      cursor: pointer; transition: background 0.15s, transform 0.08s, box-shadow 0.15s;
    }
    .btn-ghost:hover { background: rgba(18,25,60,0.95); box-shadow: 0 4px 12px rgba(0,0,0,0.4); transform: translateY(-1px); }

    .status-text { font-size: 0.8rem; color: var(--text-muted); }

    /* Filters bar */
    .filters-bar {
      background: radial-gradient(circle at left, rgba(93,208,255,0.15), rgba(10,15,45,0.98));
      border-radius: 14px; padding: 10px 12px; border: 1px solid rgba(93,208,255,0.35);
      display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-end;
      box-shadow: 0 12px 28px rgba(0,0,0,0.55);
    }
    .field { display: flex; flex-direction: column; gap: 3px; min-width: 140px; }
    .field label { font-size: 0.78rem; color: var(--text-muted); }
    select, input[type="range"] {
      background: #050816; border-radius: 10px; border: 1px solid rgba(255,255,255,0.25);
      color: var(--text-main); font-size: 0.8rem; padding: 5px 9px; outline: none; min-height: 30px;
    }
    select:focus, input[type="range"]:focus { border-color: var(--accent); box-shadow: 0 0 0 1px rgba(93,208,255,0.5); }

    /* Dual range visual */
    .timeline-wrap { min-width: 340px; }
    .timeline-controls {
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px;
      align-items: center;
    }
    .timeline-labels {
      display: flex; justify-content: space-between; font-size: 0.76rem; color: var(--text-muted); margin-top: 2px;
    }

    /* KPI panels */
    .panels-row { display: grid; grid-template-columns: 2fr 1.8fr; gap: 10px; margin-top: 8px; margin-bottom: 10px; }
    .panel {
      background: linear-gradient(135deg, rgba(14,18,40,0.98), rgba(10,12,30,0.98));
      border-radius: 14px; padding: 10px 12px; border: 1px solid var(--border-subtle);
      box-shadow: 0 14px 32px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 6px; min-height: 200px;
    }
    .panel-header { display: flex; align-items: center; justify-content: space-between; font-size: 0.9rem; }
    .panel-header-title { display: flex; align-items: center; gap: 6px; }
    .panel-header-title span.icon { font-size: 1.1rem; }

    .kpi-row {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      margin-top: 4px;
    }
    .kpi-card {
      background: radial-gradient(circle at top, rgba(93,208,255,0.2), rgba(10,15,40,0.95));
      border-radius: 12px;
      padding: 7px 9px;
      border: 1px solid rgba(93,208,255,0.4);
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 0.8rem;
    }
    .kpi-label { color: var(--text-muted); font-size: 0.75rem; }
    .kpi-value { font-size: 1rem; font-weight: 600; }
    .kpi-badge { font-size: 0.7rem; color: var(--accent); }

    /* MATRIX TABLE */
    .matrix-wrapper { margin-top: 10px; }
    .matrix-scroll {
      margin-top: 6px;
      max-height: 260px;
      overflow: auto;
    }

    .matrix-table {
      border-collapse: collapse;
      font-size: 0.78rem;
      text-align: center;
      width: max-content;
      table-layout: auto;
    }
    .matrix-table.table-wide { min-width: unset; width: max-content; }
    .matrix-table.table-fit  { min-width: unset; width: max-content; }

    .matrix-table th,
    .matrix-table td {
      border: 1px solid var(--border-subtle);
      padding: 4px 6px;
      white-space: nowrap;
    }
    .matrix-table thead th {
      background: radial-gradient(circle at top, rgba(93,208,255,0.18), rgba(10,12,30,0.96));
      position: sticky;
      top: 0;
      z-index: 1;
    }

    /* clickable sortable headers */
    .matrix-table th.sortable {
      cursor: pointer;
      user-select: none;
    }
    .matrix-table th.sortable .sort-caret {
      opacity: 0.75;
      margin-inline-start: 6px;
      font-size: 0.8em;
    }
    .matrix-table th.sortable:hover {
      filter: brightness(1.08);
    }

    .matrix-row-header {
      text-align: right;
      font-weight: 600;
      background: rgba(255,255,255,0.02);
      position: sticky;
      right: 0;
      z-index: 1;
    }

    .num {
      direction: ltr;
      unicode-bidi: isolate;
      font-variant-numeric: tabular-nums;
      text-align: center;
      display: inline-block;
      min-width: 4.8ch;
    }

    tr.row-menora td,
    tr.row-menora .matrix-row-header {
      background: rgba(34, 60, 140, 0.22) !important;
    }

    /* Views */
    .views-wrapper { margin-top: 4px; display: flex; flex-direction: column; gap: 10px; }
    .view { display: none; }
    .view.active { display: block; }

    /* Chart panel */
    .chart-title {
      margin: 6px 0 4px;
      font-size: 0.9rem;
      color: var(--text-main);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .chart-container { position: relative; width: 100%; height: 260px; }
    .chart-container.narrow-right { max-width: 1100px; margin-left: auto; margin-right: 0; }

    .chart-filters-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: flex-end;
    }

    @media (max-width: 840px) {
      .app-shell { grid-template-columns: 1fr; }
      .sidebar { display: none; }
      .main { padding: 12px; }
      .panels-row { grid-template-columns: 1fr; }
      .kpi-row { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
  </style>
</head>

<body>
<div class="app-shell">

  <!-- SIDEBAR -->
  <aside class="sidebar">
    <div class="sidebar-logo">
      <div class="sidebar-logo-icon">â§‰</div>
      <div class="sidebar-logo-text">
        <div class="sidebar-logo-title">××¨×›×™×‘×™ ×ª×©×•××”</div>
        <div class="sidebar-logo-sub">Dashboard v4.6.0</div>
      </div>
    </div>

    <div class="sidebar-nav">
      <div class="nav-item active" data-view="charts">
        <span class="icon">ğŸ“ˆ</span><span class="label">×’×¨×¤×™×</span>
      </div>
    </div>

    <div class="sidebar-meta" id="sidebar_meta">
      <span><span>×—×‘×¨×•×ª:</span><span>-</span></span>
      <span><span>××¡×œ×•×œ×™×:</span><span>-</span></span>
      <span><span>×©× ×™×:</span><span>-</span></span>
      <span><span>×¡×”×´×› ×¨×©×•××•×ª:</span><span>-</span></span>
    </div>
  </aside>

  <!-- MAIN -->
  <main class="main">

    <!-- HEADER -->
    <header class="main-header">
      <div class="main-title-block">
        <div class="main-title">×“×©×‘×•×¨×“ ××¨×›×™×‘×™ ×ª×©×•××”</div>
        <div class="main-subtitle">
          ×’×¨×¤×™× + ×˜×‘×œ×ª ××˜×¨×™×¦×” ×œ×¤×™ ××¡×œ×•×œ / ×©× ×” / ×¨×‘×¢×•×Ÿ
        </div>
      </div>
      <div class="main-header-actions">
        <div class="badge-file" id="badge_file">×§×•×‘×¥: -</div>
        <button class="btn-ghost" type="button" id="btn_reload">â†» ×¨×¢× ×•×Ÿ × ×ª×•× ×™×</button>
      </div>
    </header>

    <!-- KPI ABOVE FILTERS -->
    <section class="panels-row">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-header-title"><span class="icon">ğŸ“Š</span><span>××“×“×™ ××¤×ª×— â€“ ×¡×™×›×•×</span></div>
        </div>
        <div class="kpi-row" id="kpi_row"></div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <div class="panel-header-title"><span class="icon">â„¹ï¸</span><span>×¡×˜×˜×•×¡ ×¤×™×œ×˜×¨×™×</span></div>
        </div>
        <div class="status-text" id="status_filters">×˜×•×¢×Ÿ × ×ª×•× ×™×...</div>
      </div>
    </section>

    <!-- FILTERS -->
    <section class="filters-bar">

      <div class="field">
        <label>×ª×¦×•×’×ª ×¢××•×“×•×ª</label>
        <select id="col_mode">
          <option value="quarter">×œ×¤×™ ×¨×‘×¢×•×Ÿ</option>
          <option value="year">×œ×¤×™ ×©× ×™×</option>
        </select>
      </div>

      <div class="field">
        <label>×©×“×•×ª ×œ×˜×‘×œ×”</label>
        <select id="f_cols" multiple></select>
      </div>

      <div class="field">
        <label>×¡×•×’ ×—×™×¡×›×•×Ÿ</label>
        <select id="f_saving_type"></select>
      </div>

      <div class="field">
        <label>×¡×•×’ ×§×•×¤×”</label>
        <select id="f_fund_type"></select>
      </div>

      <div class="field">
        <label>××¡×œ×•×œ</label>
        <select id="f_track" multiple></select>
      </div>

      <div class="field">
        <label>×¡×—×™×¨×•×ª</label>
        <select id="f_liquidity"></select>
      </div>

      <div class="field">
        <label>××¤×™×§ ×”×©×§×¢×”</label>
        <select id="f_category" multiple></select>
      </div>

      <div class="field">
        <label>×©× ×ª ×“×™×•×•×—</label>
        <select id="f_year" multiple></select>
      </div>

      <div class="field timeline-wrap">
        <label>×¦×™×¨ ×–××Ÿ (×©× ×”/×¨×‘×¢×•×Ÿ) â€“ ×’×¨×•×¨ ×™××™×Ÿ/×©×××œ</label>
        <div class="timeline-controls">
          <input id="tl_start" type="range" min="0" max="0" step="1" value="0" />
          <input id="tl_end"   type="range" min="0" max="0" step="1" value="0" />
        </div>
        <div class="timeline-labels">
          <span id="tl_label_start">-</span>
          <span id="tl_label_end">-</span>
        </div>
      </div>

    </section>

    <!-- MATRIX TABLE -->
    <section class="matrix-wrapper">
      <div class="panel">
        <div class="panel-header">
          <div class="panel-header-title">
            <span class="icon">ğŸ§®</span>
            <span id="matrix_title">××˜×¨×™×¦×ª ×©×™×¢×•×¨ ××¡×š ×”×ª×™×§, ×ª×©×•××”, ×“×™×¨×•×’×™× ×•×¡×™×›×•× ×ª×§×•×¤×”</span>
          </div>
        </div>
        <div id="matrix_empty" class="status-text" style="margin-top:4px; display:none;">
          ××™×Ÿ × ×ª×•× ×™× ×œ×”×¦×’×” ×¢×‘×•×¨ ×”××¡× × ×™× ×”× ×•×›×—×™×™×.
        </div>
        <div id="matrix_no_fields" class="status-text" style="margin-top:4px; display:none;">
          ×‘×—×¨ ×©×“×•×ª ×œ×”×¦×’×” ××ª×•×š â€œ×©×“×•×ª ×œ×˜×‘×œ×”â€.
        </div>
        <div class="matrix-scroll">
          <table id="matrix_table" class="matrix-table table-wide"></table>
        </div>
      </div>
    </section>

    <!-- CHARTS VIEW -->
    <section class="views-wrapper">
      <section class="view active" id="view_charts">

        <div class="panel">
          <div class="panel-header">
            <div class="panel-header-title"><span class="icon">ğŸ“ˆ</span><span>×’×¨×¤×™×</span></div>
            <div class="panel-header-sub">×©× ×™ ×”×’×¨×¤×™× ×”×¢×œ×™×•× ×™× ×¨×‘×¢×•× ×™×™× â€¢ ×¦×™×¨ Y ×‘××—×•×–×™×</div>
          </div>

          <div class="chart-block">
            <div class="chart-title">×ª×©×•××” ×¨×‘×¢×•× ×™×ª (%)</div>
            <div class="chart-container">
              <canvas id="chart_yield"></canvas>
            </div>
          </div>

          <div class="chart-block">
            <div class="chart-title">××—×–×§×” ×¨×‘×¢×•× ×™×ª ×××•×¦×¢×ª ×œ×ª×¦×•×’×” (%)</div>
            <div class="chart-container">
              <canvas id="chart_weight"></canvas>
            </div>
          </div>

          <div class="chart-filters-row">
            <div class="field">
              <label>×©× ×” (×’×¨×£ ××—×–×§×” ×œ×¤×™ ××¡×œ×•×œ ×•×¡×—×™×¨×•×ª)</label>
              <select id="liq_year_filter"></select>
            </div>
            <div class="field" id="liq_q_field">
              <label>×¨×‘×¢×•×Ÿ</label>
              <select id="liq_quarter_filter"></select>
            </div>
          </div>

          <div class="chart-block">
            <div class="chart-title" id="liq_chart_title">××—×–×§×” ×œ×¤×™ ××¡×œ×•×œ ×•×¡×—×™×¨×•×ª (%)</div>
            <div class="chart-container narrow-right">
              <canvas id="chart_liquidity"></canvas>
            </div>
          </div>
        </div>

      </section>
    </section>

  </main>
</div>

<script>
/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   STATE
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
const state = {
  raw: [],
  filtered: [],
  meta: {},
  chartYield: null,
  chartWeight: null,
  chartLiquidity: null,
  timeKeys: [],
  timeLabels: [],
  timeIndexMap: new Map(),
  tlStart: 0,
  tlEnd: 0,
  /* sorting state */
  sort: null // { type:'track'|'cum'|'cell', dir:'asc'|'desc', year?:number, quarter?:number|null, fieldKey?:'yield'|'weight'|'rank_yield'|'rank_weight' }
};

/* Filters metadata */
const FILTERS = {
  saving_type: { id: "f_saving_type", field: "saving_type",   sort: "locale" },
  fund_type:   { id: "f_fund_type",   field: "fund_type",     sort: "locale" },
  track:       { id: "f_track",       field: "track_name",    sort: "locale",  multi: true },
  liquidity:   { id: "f_liquidity",   field: "liquidity",     sort: "locale" },
  category:    { id: "f_category",    field: "category",      sort: "locale",  multi: true },
  year:        { id: "f_year",        field: "year",          sort: "numeric", multi: true }
};

/* Cell-level fields shown inside each period */
const TABLE_FIELDS = [
  { key: "weight",     label: "×©×™×¢×•×¨ ××¡×š ×”×ª×™×§ (%)" },
  { key: "yield",      label: "×ª×©×•××” (%)" },
  { key: "rank_yield", label: "×“×™×¨×•×’ ×ª×©×•××”" },
  { key: "rank_weight",label: "×“×™×¨×•×’ ××¡×š ×”×ª×™×§" }
];

/* Summary columns (controlled via â€œ×©×“×•×ª ×œ×˜×‘×œ×”â€) */
const SUMMARY_FIELDS = [
  { key: "sum_cum_return",  label: "×¡×™×›×•××™×: ×ª×©×•××” ××¦×˜×‘×¨×ª" },
  { key: "sum_rank_yield",  label: "×¡×™×›×•××™×: ×“×™×¨×•×’ ×ª×©×•××” (×œ×¤×™ ××¦×˜×‘×¨×ª)" },
  { key: "sum_avg_weight",  label: "×¡×™×›×•××™×: ××—×–×§×” ×××•×¦×¢×ª (%)" },
  { key: "sum_rank_weight", label: "×¡×™×›×•××™×: ×“×™×¨×•×’ ××—×–×§×”" }
];


/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   UTILITIES
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function safeNumber(v) { const x = Number(v); return isNaN(x) ? null : x; }
function nz(v){ const x=safeNumber(v); return x==null?0:x; }

function setSelectOptions(selectEl, values, { includeAll = true, allLabel = "×”×›×•×œ" } = {}) {
  const frag = document.createDocumentFragment();
  selectEl.innerHTML = "";
  if (includeAll) {
    const o = document.createElement("option");
    o.value = "";
    o.textContent = allLabel;
    frag.appendChild(o);
  }
  values.forEach(v => {
    const o = document.createElement("option");
    if (typeof v === "object" && v.value !== undefined) {
      o.value = String(v.value);
      o.textContent = String(v.text);
    } else {
      o.value = String(v);
      o.textContent = String(v);
    }
    frag.appendChild(o);
  });
  selectEl.appendChild(frag);
}

function uniqueSortedYears(rows) {
  return Array.from(new Set(rows.map(r => r.year).filter(v => Number(v) >= 2022)))
    .sort((a,b)=>a-b);
}
function getSelectValues(sel, multi=false) {
  return multi ? Array.from(sel.selectedOptions).map(o=>o.value).filter(v=>v!=="") : (sel.value || "");
}

/* timeline */
function buildGlobalTimeline() {
  const set = new Set();
  state.raw.forEach(r=>{
    const y = Number(r.year), q = Number(r.quarter);
    if (y>=2022 && q>=1 && q<=4) set.add(`${y}|${q}`);
  });
  const keys = Array.from(set).sort((a,b)=>{
    const [ya,qa]=a.split("|").map(Number);
    const [yb,qb]=b.split("|").map(Number);
    return ya===yb ? qa-qb : ya-yb;
  });
  state.timeKeys = keys;
  state.timeLabels = keys.map(k=>{ const [y,q]=k.split("|"); return `${y} Q${q}`; });
  state.timeIndexMap = new Map(keys.map((k,i)=>[k,i]));

  const startEl = document.getElementById("tl_start");
  const endEl   = document.getElementById("tl_end");
  const lblS    = document.getElementById("tl_label_start");
  const lblE    = document.getElementById("tl_label_end");

  const max = Math.max(0, keys.length-1);
  startEl.min = 0; startEl.max = String(max);
  endEl.min   = 0; endEl.max   = String(max);

  state.tlStart = 0; state.tlEnd = max;
  startEl.value = String(state.tlStart);
  endEl.value   = String(state.tlEnd);
  lblS.textContent = keys.length ? state.timeLabels[state.tlStart] : "-";
  lblE.textContent = keys.length ? state.timeLabels[state.tlEnd]   : "-";
}
function hookTimelineEvents() {
  const startEl = document.getElementById("tl_start");
  const endEl   = document.getElementById("tl_end");
  const lblS    = document.getElementById("tl_label_start");
  const lblE    = document.getElementById("tl_label_end");

  const clampUpdate = ()=>{
    let s = Number(startEl.value);
    let e = Number(endEl.value);
    if (s > e) {
      if (s - state.tlStart > e - state.tlEnd) endEl.value = String(s);
      else startEl.value = String(e);
    }
    state.tlStart = Number(startEl.value);
    state.tlEnd   = Number(endEl.value);
    lblS.textContent = state.timeLabels[state.tlStart] ?? "-";
    lblE.textContent = state.timeLabels[state.tlEnd]   ?? "-";
    applyFilters();
  };
  startEl.addEventListener("input", clampUpdate);
  endEl.addEventListener("input", clampUpdate);
}
function inTimelineRange(row) {
  const y = Number(row.year), q = Number(row.quarter);
  if (!(y && q)) return false;
  const key = `${y}|${q}`;
  const idx = state.timeIndexMap.get(key);
  return idx!==undefined && idx>=state.tlStart && idx<=state.tlEnd;
}

/* NAV */
document.querySelectorAll(".nav-item").forEach(item => {
  item.addEventListener("click", () => {
    document.querySelectorAll(".nav-item").forEach(n=>n.classList.remove("active"));
    item.classList.add("active");
    document.querySelectorAll(".view").forEach(v => v.classList.remove("active"));
    const name = item.dataset.view;
    document.getElementById("view_"+name).classList.add("active");
    if (name === "charts") renderCharts();
  });
});

/* LOAD DATA */
async function reloadData() {
  document.getElementById("status_filters").textContent = "×˜×•×¢×Ÿ × ×ª×•× ×™×...";
  try {
    const res = await fetch("/api/data");
    const json = await res.json();
    state.raw = json.rows || [];
    state.meta = json.meta || {};
    document.getElementById("badge_file").textContent = "×§×•×‘×¥: " + (state.meta.file || "-");
    updateSidebarMeta();
    buildFilters();
    buildGlobalTimeline();
    hookTimelineEvents();
    refreshFilterOptions();
    applyFilters();
  } catch (err) { console.error(err); }
}
function updateSidebarMeta() {
  const m = state.meta || {};
  document.getElementById("sidebar_meta").innerHTML = `
    <span><span>×—×‘×¨×•×ª:</span><span>${(m.companies||[]).length}</span></span>
    <span><span>××¡×œ×•×œ×™×:</span><span>${(m.tracks||[]).length}</span></span>
    <span><span>×©× ×™×:</span><span>${(m.years||[]).join(", ")||"-"}</span></span>
    <span><span>×¡×”×´×› ×¨×©×•××•×ª:</span><span>${m.total_rows || "-"}</span></span>
  `;
}

/* FILTERS */
function buildFilters() {
  const rows = state.raw;
  const savingTypes = Array.from(new Set(rows.map(r=>r.saving_type).filter(Boolean))).sort((a,b)=>a.localeCompare(b,"he"));
  const fundTypes   = Array.from(new Set(rows.map(r=>r.fund_type).filter(Boolean))).sort((a,b)=>a.localeCompare(b,"he"));
  const tracks      = Array.from(new Set(rows.map(r=>r.track_name).filter(Boolean))).sort((a,b)=>a.localeCompare(b,"he"));
  const liquidities = Array.from(new Set(rows.map(r=>r.liquidity).filter(Boolean))).sort((a,b)=>a.localeCompare(b,"he"));
  const categories  = Array.from(new Set(rows.map(r=>r.category).filter(Boolean))).sort((a,b)=>a.localeCompare(b,"he"));
  const years       = uniqueSortedYears(rows);

  setSelectOptions(document.getElementById("f_saving_type"), savingTypes);
  setSelectOptions(document.getElementById("f_fund_type"),   fundTypes);
  setSelectOptions(document.getElementById("f_track"),       tracks, { includeAll:false });
  setSelectOptions(document.getElementById("f_liquidity"),   liquidities);
  setSelectOptions(document.getElementById("f_category"),    categories, { includeAll:false });
  setSelectOptions(document.getElementById("f_year"),        years,      { includeAll:false });

  /* DEFAULTS (×˜×¢×™× ×” ×¨××©×•× ×”) */
  const defaultSaving   = "×”×©×ª×œ××•×ª";
  const defaultFundType = "×›×œ×œ×™";
  const defaultTrack    = "×›×œ×œ×™";

  const selSaving = document.getElementById("f_saving_type");
  const selFund   = document.getElementById("f_fund_type");
  const selTrack  = document.getElementById("f_track");

  if ([...selSaving.options].some(o=>o.value===defaultSaving))   selSaving.value = defaultSaving;
  if ([...selFund.options].some(o=>o.value===defaultFundType))   selFund.value   = defaultFundType;
  if ([...selTrack.options].some(o=>o.value===defaultTrack))     selTrack.value  = defaultTrack;

  /* Columns selector */
  const colsSel = document.getElementById("f_cols");
  const allOptions = [
    ...SUMMARY_FIELDS.map(f => ({ value: f.key, text: f.label })),
    ...TABLE_FIELDS.map(f => ({ value: f.key, text: f.label }))
  ];
  setSelectOptions(colsSel, allOptions, { includeAll:false });
  Array.from(colsSel.options).forEach(o => o.selected = true);

  ["f_saving_type","f_fund_type","f_track","f_liquidity","f_category","f_year"].forEach(id=>{
    document.getElementById(id).addEventListener("change", ()=>{ refreshFilterOptions(); applyFilters(); });
  });
  document.getElementById("col_mode").addEventListener("change", ()=>{
    toggleLiquidityQuarterVisibility();
    refreshLiquidityFilters();
    applyFilters();
  });
  colsSel.addEventListener("change", ()=>{ renderMatrixTable(); });

  const ly = document.getElementById("liq_year_filter");
  const lq = document.getElementById("liq_quarter_filter");
  if (ly) ly.addEventListener("change", ()=>{ refreshLiquidityFilters(); renderLiquidityChart(); });
  if (lq) lq.addEventListener("change", ()=>{ renderLiquidityChart(); });

  toggleLiquidityQuarterVisibility();
}
function getCurrentFilters() {
  return {
    saving_type: getSelectValues(document.getElementById("f_saving_type")),
    fund_type:   getSelectValues(document.getElementById("f_fund_type")),
    track:       getSelectValues(document.getElementById("f_track"), true),
    liquidity:   getSelectValues(document.getElementById("f_liquidity")),
    category:    getSelectValues(document.getElementById("f_category"), true),
    year:        getSelectValues(document.getElementById("f_year"), true),
    col_mode:    document.getElementById("col_mode").value || "quarter",
    table_cols:  getSelectValues(document.getElementById("f_cols"), true)
  };
}
function refreshFilterOptions() {
  const filters = getCurrentFilters();
  const rows = state.raw;

  Object.entries(FILTERS).forEach(([key,meta])=>{
    const sel = document.getElementById(meta.id);
    const isMulti = !!meta.multi;
    const prev = isMulti ? Array.from(sel.selectedOptions).map(o=>o.value) : [sel.value];

    const rowsForKey = rows.filter(r=>{
      if (key!=="saving_type" && filters.saving_type && r.saving_type !== filters.saving_type) return false;
      if (key!=="fund_type"   && filters.fund_type   && r.fund_type   !== filters.fund_type)   return false;
      if (key!=="track"       && Array.isArray(filters.track) && filters.track.length && !filters.track.includes(r.track_name)) return false;
      if (key!=="liquidity"   && filters.liquidity   && r.liquidity   !== filters.liquidity)   return false;
      if (key!=="category" && Array.isArray(filters.category) && filters.category.length && !filters.category.includes(r.category)) return false;
      if (key!=="year" && Array.isArray(filters.year) && filters.year.length && !filters.year.includes(String(r.year))) return false;
      return true;
    });

    let vals = Array.from(new Set(rowsForKey.map(r=>r[meta.field]).filter(Boolean)));
    if (meta.sort==="numeric") vals.sort((a,b)=>a-b);
    else vals.sort((a,b)=>String(a).localeCompare(String(b),"he"));

    setSelectOptions(sel, vals, { includeAll:!isMulti });

    if (isMulti) {
      Array.from(sel.options).forEach(o=> o.selected = prev.includes(o.value));
    } else {
      const keep = prev.find(v => v !== "" && vals.includes(v));
      sel.value = keep ?? "";
    }
  });
}

/* APPLY FILTERS */
function applyFilters() {
  const f = getCurrentFilters();
  const rows = state.raw.filter(r=>Number(r.year)>=2022);

  state.filtered = rows.filter(r=>{
    if (f.saving_type && r.saving_type !== f.saving_type) return false;
    if (f.fund_type   && r.fund_type   !== f.fund_type)   return false;
    if (Array.isArray(f.track) && f.track.length && !f.track.includes(r.track_name)) return false;
    if (f.liquidity   && r.liquidity   !== f.liquidity)   return false;
    if (Array.isArray(f.category) && f.category.length && !f.category.includes(r.category)) return false;
    if (Array.isArray(f.year) && f.year.length && !f.year.includes(String(r.year))) return false;
    if (!inTimelineRange(r)) return false;
    return true;
  });

  refreshLiquidityFilters();
  updateFiltersStatus();
  renderKPIs();
  renderMatrixTable();
  renderCharts();
}
function updateFiltersStatus() {
  const f = getCurrentFilters();
  const cnt = state.filtered.length;

  const labelByKey = new Map([
    ...SUMMARY_FIELDS.map(x=>[x.key,x.label]),
    ...TABLE_FIELDS.map(x=>[x.key,x.label]),
  ]);
  const selectedLabels = (f.table_cols||[]).map(k=>labelByKey.get(k)).filter(Boolean);

  const parts = [];
  parts.push("×ª×¦×•×’×ª ×¢××•×“×•×ª: " + (f.col_mode==="quarter" ? "×œ×¤×™ ×¨×‘×¢×•×Ÿ" : "×œ×¤×™ ×©× ×™×"));
  if (f.saving_type) parts.push("×¡×•×’ ×—×™×¡×›×•×Ÿ: "+f.saving_type);
  if (f.fund_type)   parts.push("×¡×•×’ ×§×•×¤×”: "+f.fund_type);
  if (Array.isArray(f.track) && f.track.length) parts.push("××¡×œ×•×œ: "+f.track.join(", "));
  if (f.liquidity)   parts.push("×¡×—×™×¨×•×ª: "+f.liquidity);
  if (f.category.length) parts.push("××¤×™×§: "+f.category.join(", "));
  if (f.year.length)     parts.push("×©× ×™×: "+f.year.join(", "));
  if (state.timeKeys.length) parts.push(`×˜×•×•×— ×–××Ÿ: ${state.timeLabels[state.tlStart]} â†’ ${state.timeLabels[state.tlEnd]}`);
  if (selectedLabels.length) parts.push("×©×“×•×ª ×‘×˜×‘×œ×”: "+selectedLabels.join(", "));

  document.getElementById("status_filters").textContent =
    (parts.length ? parts.join(" â€¢ ") : "×œ×œ× ×¡×™× ×•×Ÿ") +
    ` â€¢ ×¨×©×•××•×ª ×œ××—×¨ ×¡×™× ×•×Ÿ: ${cnt}`;
}

/* KPI */
function renderKPIs() {
  const rows = state.filtered;
  const kpi = document.getElementById("kpi_row");

  if (!rows.length) {
    kpi.innerHTML = `<div class="kpi-card"><div class="kpi-label">××™×Ÿ × ×ª×•× ×™×</div><div class="kpi-value">0</div></div>`;
    return;
  }

  const companies = new Set(rows.map(r=>r.company_short));
  const tracks    = new Set(rows.map(r=>r.track_name));

  kpi.innerHTML = `
    <div class="kpi-card">
      <div class="kpi-label">×—×‘×¨×•×ª ×‘×¤×™×œ×˜×¨</div>
      <div class="kpi-value">${companies.size}</div>
      <div class="kpi-badge">××ª×•×š ${(state.meta.companies||[]).length}</div>
    </div>
    <div class="kpi-card">
      <div class="kpi-label">××¡×œ×•×œ×™× ×‘×¤×™×œ×˜×¨</div>
      <div class="kpi-value">${tracks.size}</div>
      <div class="kpi-badge">×¡×”×´×› ×¨×©×•××•×ª: ${rows.length}</div>
    </div>
  `;
}

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
   RETURNS LOGIC (NEW)
   We receive cumulative return proxy per period: R_q â‰ˆ contribution/weight.
   We convert to true per-quarter returns:
   r1 = R1
   r2 = (1+R2)/(1+R1) - 1
   r3 = (1+R3)/(1+R2) - 1
   r4 = (1+R4)/(1+R3) - 1
   Annual return per year = Î (1+r_q) - 1
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */

/* Build aggregated map by track/year/quarter (sum weights & contributions) */
function buildAgg(rows){
  const agg = {};
  rows.forEach(r => {
    const t=r.track_name, y=Number(r.year), q=Number(r.quarter)||null;
    const w=nz(r.weight), c=nz(r.contribution);
    if (!t || !y || !q) return;
    if (!agg[t]) agg[t]={};
    if (!agg[t][y]) agg[t][y]={};
    if (!agg[t][y][q]) agg[t][y][q]={w:0,c:0};
    agg[t][y][q].w += w; agg[t][y][q].c += c;
  });
  return agg;
}

/* From agg with cumulative R=c/w per period, compute per-quarter r and annual */
function derivePeriodAndAnnual(agg){
  const period = {};   // period[track][year][q] = r_q (number)
  const annual = {};   // annual[track][year]     = R_year (number)
  Object.keys(agg).forEach(t=>{
    period[t]={}; annual[t]={};
    Object.keys(agg[t]).map(Number).sort((a,b)=>a-b).forEach(y=>{
      const qs = Object.keys(agg[t][y]).map(Number).filter(Boolean).sort((a,b)=>a-b);
      let prevR = null;
      let prod = 1.0;
      period[t][y]={};
      qs.forEach(q=>{
        const cell = agg[t][y][q];
        const Rq = (cell && Math.abs(cell.w)>1e-12) ? (cell.c/cell.w) : null;
        let rq = null;
        if (Rq==null) rq=null;
        else if (prevR==null) rq = Rq; // r1 = R1
        else rq = (1+Rq)/(1+prevR) - 1;
        period[t][y][q] = rq;
        if (rq!=null) prod *= (1+rq);
        prevR = Rq;
      });
      annual[t][y] = (prod===1.0) ? null : (prod - 1);
    });
  });
  return { period, annual };
}
/* â€”â€”â€” Helpers for summary coverage & metrics â€”â€”â€” */
function collectTargetPeriods(yearsDesc, activeQuartersByYear, mode){
  // ××—×–×™×¨ ××¢×¨×š ×©×œ {y, q} ×›××©×¨ ×‘Ö¾year mode q=null
  const targets = [];
  if (mode === "quarter") {
    yearsDesc.forEach(y=>{
      (activeQuartersByYear.get(y)||[]).slice().reverse().forEach(q=>{
        targets.push({y, q});
      });
    });
  } else {
    yearsDesc.forEach(y=> targets.push({y, q:null}));
  }
  return targets;
}

function computeSummariesForTrack(track, mode, yearsDesc, activeQuartersByYear, periodR, annualR, agg){
  const targets = collectTargetPeriods(yearsDesc, activeQuartersByYear, mode);
  if (!targets.length) return { full:false, cum:null, avgW:null };

  let prod = 1.0;
  let wSum = 0.0;
  let n = 0;

  for (const {y,q} of targets){
    if (mode === "quarter"){
      const rq = periodR?.[track]?.[y]?.[q] ?? null;
      const cell = agg?.[track]?.[y]?.[q] ?? null;
      const w   = (cell && Math.abs(cell.w)>1e-12) ? cell.w : null;

      // ×›×™×¡×•×™ ××œ×: ×× ×œ× ×§×™×™××™× ×’× ×ª×©×•××” ×¨×‘×¢×•× ×™×ª ×•×’× ××©×§×œ â€” ××™×Ÿ ×¢×¨×š ×œ×¡×™×›×•×
      if (rq==null || w==null) return { full:false, cum:null, avgW:null };

      prod *= (1 + rq);
      wSum += w;
      n += 1;
    } else {
      const Ry = annualR?.[track]?.[y] ?? null;
      // ×œ××—×•×–×™ ××—×–×§×” ×©× ×ª×™×™× × ×©×ª××© ×‘×¨×‘×¢×•×Ÿ ×”××—×¨×•×Ÿ ×”×§×™×™× ×‘×©× ×” ×”×–××ª (×›××• ×‘×œ×•×’×™×§×” ×”×§×™×™××ª)
      const bq = bestQuarterForYear(agg, track, y);
      const cell = bq ? (agg?.[track]?.[y]?.[bq] ?? null) : null;
      const w = (cell && Math.abs(cell.w)>1e-12) ? cell.w : null;

      if (Ry==null || w==null) return { full:false, cum:null, avgW:null };

      prod *= (1 + Ry);
      wSum += w;
      n += 1;
    }
  }

  return {
    full: true,
    cum:  prod - 1,            // ×ª×©×•××” ××¦×˜×‘×¨×ª ××¡×¤×¨×™×ª
    avgW: n ? (wSum / n) : null // ×××•×¦×¢ ××—×–×§×” (×‘×™×Ÿ 0 ×œÖ¾1)
  };
}

/* Helpers for table width */
function selectedTableFields() {
  const f = getCurrentFilters();
  const keys = (f.table_cols||[]).filter(k => TABLE_FIELDS.some(x=>x.key===k));
  return TABLE_FIELDS.filter(x => keys.includes(x.key));
}
function selectedSummaryKeys() {
  const f = getCurrentFilters();
  return (f.table_cols||[]).filter(k => SUMMARY_FIELDS.some(x=>x.key===k));
}
function applyMatrixTableWidthMode() {
  const table = document.getElementById("matrix_table");
  if (!table) return;
  const mode = document.getElementById("col_mode").value || "quarter";
  table.classList.remove("table-wide","table-fit");
  if (mode === "quarter") table.classList.add("table-wide");
  else                    table.classList.add("table-fit");
}
function isActiveCell(cell){
  if (!cell) return false;
  return (Math.abs(cell.w||0)>1e-9) || (Math.abs(cell.c||0)>1e-9);
}
function bestQuarterForYear(agg, track, year) {
  for (const q of [4,3,2,1]) if (agg?.[track]?.[year]?.[q]) return q;
  return null;
}

/* summary (updated to use period/annual) */
function computeTrackSummaryCum_fromPeriod(periodMap, annualMap, track, yearsDesc, yearMap, mode) {
  let product = 1.0;
  let touched = false;

  if (mode === "quarter") {
    yearsDesc.forEach(y=>{
      (yearMap.get(y)||[]).slice().reverse().forEach(qDesc=>{
        // yearMap holds quarters DESC (later), but we just multiply irrespective of order
        const rq = periodMap?.[track]?.[y]?.[qDesc];
        if (rq!=null) { product *= (1+rq); touched = true; }
      });
    });
  } else {
    yearsDesc.forEach(y=>{
      const Ry = annualMap?.[track]?.[y];
      if (Ry!=null) { product *= (1+Ry); touched = true; }
    });
  }

  const cumReturn = touched ? (product - 1) : null;
  return cumReturn==null ? "-" : (cumReturn*100).toFixed(2)+"%";
}

/* sorting helpers */
function parsePercentText(txt){
  if (txt==null || txt==="-" || txt==="") return null;
  const v = Number(String(txt).replace("%","").trim());
  return Number.isFinite(v) ? v : null;
}
function compareValues(a,b,dir){
  const mul = dir==='asc' ? 1 : -1;
  if (a==null && b==null) return 0;
  if (a==null) return 1 * mul;
  if (b==null) return -1 * mul;
  if (typeof a === "number" && typeof b === "number") return (a===b?0:(a<b?-1:1)) * mul;
  return String(a).localeCompare(String(b),"he") * mul;
}
function flipDir(dir){ return dir==='asc' ? 'desc' : 'asc'; }
function clearHeaderCarets(thead){
  thead.querySelectorAll('.sort-caret').forEach(el=> el.textContent="");
}
function setCaret(el,dir){
  let caret = el.querySelector(".sort-caret");
  if (!caret){ caret = document.createElement("span"); caret.className="sort-caret"; el.appendChild(caret); }
  caret.textContent = dir==='asc' ? "â–²" : "â–¼";
}

/* RENDER MATRIX TABLE (with sorting) */
function renderMatrixTable() {
  const table    = document.getElementById("matrix_table");
  const emptyEl  = document.getElementById("matrix_empty");
  const noFieldsEl = document.getElementById("matrix_no_fields");
  const titleEl  = document.getElementById("matrix_title");
  if (!table) return;

  const mode = document.getElementById("col_mode").value || "quarter";
  const rows = state.filtered.filter(r => r.track_name && r.year);

  const cellFields   = selectedTableFields();
  const summaryKeys  = selectedSummaryKeys(); // e.g. ["sum_cum_return","sum_avg_weight","sum_rank_yield","sum_rank_weight"]
  const hasAnySummary = summaryKeys.length > 0;

  table.replaceChildren();

  if (!rows.length) {
    emptyEl.style.display = "block";
    noFieldsEl.style.display = "none";
    applyMatrixTableWidthMode();
    return;
  }
  emptyEl.style.display = "none";

  if (cellFields.length === 0 && !hasAnySummary) {
    noFieldsEl.style.display = "block";
    applyMatrixTableWidthMode();
    return;
  }
  noFieldsEl.style.display = "none";

  // Build years/tracks and aggregate (cumulative), then derive period and annual
  const yearMap = new Map();
  rows.forEach(r => {
    const y = Number(r.year);
    const q = Number(r.quarter);
    if (!y) return;
    if (!yearMap.has(y)) yearMap.set(y, new Set());
    if (q) yearMap.get(y).add(q);
  });
  const yearsAll = Array.from(yearMap.keys()).sort((a,b)=>b-a);
  yearsAll.forEach(y => yearMap.set(y, Array.from(yearMap.get(y)).sort((a,b)=>b-a))); // store DESC for header

  const trackNames = Array.from(new Set(rows.map(r => r.track_name)))
    .sort((a,b)=>String(a).localeCompare(String(b),"he"));

  const agg = buildAgg(rows);
  const { period: periodR, annual: annualR } = derivePeriodAndAnnual(agg);

  let years = [];
  const activeQuartersByYear = new Map();
  if (mode === "quarter") {
    years = yearsAll.filter(y=>{
      const qs = yearMap.get(y)||[];
      const activeQs = qs.filter(q=> trackNames.some(t => periodR?.[t]?.[y]?.[q] != null));
      if (activeQs.length) activeQuartersByYear.set(y, activeQs);
      return activeQs.length > 0;
    });
  } else {
    years = yearsAll.filter(y=> trackNames.some(t => annualR?.[t]?.[y] != null));
  }

  if (!years.length) {
    emptyEl.style.display = "block";
    applyMatrixTableWidthMode();
    return;
  }

  // ---------- Helpers (local to this function) ----------
  function makeSortable(th, sortSpec){
    th.classList.add("sortable");
    th.addEventListener("click", ()=>{
      const same =
        state.sort &&
        state.sort.type === sortSpec.type &&
        state.sort.year === sortSpec.year &&
        (state.sort.quarter ?? null) === (sortSpec.quarter ?? null) &&
        state.sort.fieldKey === sortSpec.fieldKey;
      const dir = same ? flipDir(state.sort.dir) : 'desc';
      state.sort = {...sortSpec, dir};
      renderMatrixTable();
      renderCharts();
    });
    const isActive =
      state.sort &&
      state.sort.type === sortSpec.type &&
      state.sort.year === sortSpec.year &&
      (state.sort.quarter ?? null) === (sortSpec.quarter ?? null) &&
      state.sort.fieldKey === sortSpec.fieldKey;
    if (isActive) setCaret(th, state.sort.dir);
  }
  function thWith({text="", attrs={}, html=""}) {
    const th = document.createElement("th");
    if (text) th.textContent = text;
    if (html) th.innerHTML = html;
    Object.entries(attrs).forEach(([k,v])=> th.setAttribute(k,v));
    return th;
  }
  function tdWith({text="", html="", cls=""}) {
    const td = document.createElement("td");
    if (cls) td.className = cls;
    if (html) td.innerHTML = html; else td.textContent = text;
    return td;
  }
  function collectTargetPeriods(yearsDesc, activeQuartersByYear, mode){
    const targets = [];
    if (mode === "quarter") {
      yearsDesc.forEach(y=>{
        (activeQuartersByYear.get(y)||[]).slice().reverse().forEach(q=>{
          targets.push({y, q});
        });
      });
    } else {
      yearsDesc.forEach(y=> targets.push({y, q:null}));
    }
    return targets;
  }
  // Coverage rule: if any selected period is missing yield or weight -> summaries are null (no participation in ranks)
  function computeSummariesForTrack(track, mode, yearsDesc, activeQuartersByYear, periodR, annualR, agg){
    const targets = collectTargetPeriods(yearsDesc, activeQuartersByYear, mode);
    if (!targets.length) return { full:false, cum:null, avgW:null };

    let prod = 1.0;
    let wSum = 0.0;
    let n = 0;

    for (const {y,q} of targets){
      if (mode === "quarter"){
        const rq   = periodR?.[track]?.[y]?.[q] ?? null;
        const cell = agg?.[track]?.[y]?.[q] ?? null;
        const w    = (cell && Math.abs(cell.w)>1e-12) ? cell.w : null;
        if (rq==null || w==null) return { full:false, cum:null, avgW:null };
        prod *= (1 + rq);
        wSum += w;
        n += 1;
      } else {
        const Ry = annualR?.[track]?.[y] ?? null;
        const bq = bestQuarterForYear(agg, track, y);
        const cell = bq ? (agg?.[track]?.[y]?.[bq] ?? null) : null;
        const w = (cell && Math.abs(cell.w)>1e-12) ? cell.w : null;
        if (Ry==null || w==null) return { full:false, cum:null, avgW:null };
        prod *= (1 + Ry);
        wSum += w;
        n += 1;
      }
    }
    return { full:true, cum: prod - 1, avgW: n ? (wSum / n) : null };
  }


  // ---------- Pre-compute period ranks (existing logic) ----------
  function buildRankMapsQuarter(){
    const rankReturnMap={}; const rankWeightMap={};
    years.forEach(y=>{
      rankReturnMap[y]={}; rankWeightMap[y]={};
      (activeQuartersByYear.get(y)||[]).forEach(q=>{
        const arrR=[], arrW=[];
        trackNames.forEach(t=>{
          const cell = agg?.[t]?.[y]?.[q];
          const rq = periodR?.[t]?.[y]?.[q];
          if (rq!=null) arrR.push({t,val:rq});
          if (cell && Math.abs(cell.w)>1e-12) arrW.push({t,val:cell.w});
        });
        arrR.sort((a,b)=>b.val-a.val);
        arrW.sort((a,b)=>b.val-a.val);
        const mR={}; arrR.forEach((o,i)=>mR[o.t]={rank:i+1,total:arrR.length});
        const mW={}; arrW.forEach((o,i)=>mW[o.t]={rank:i+1,total:arrW.length});
        rankReturnMap[y][q]=mR; rankWeightMap[y][q]=mW;
      });
    });
    return {rankReturnMap,rankWeightMap};
  }
  function buildRankMapsYear(){
    const rankReturnYear={}, rankWeightYear={};
    years.forEach(y=>{
      const arrR=[], arrW=[];
      trackNames.forEach(t=>{
        const Ry = annualR?.[t]?.[y];
        const bq=bestQuarterForYear(agg,t,y); const cell=bq? agg[t]?.[y]?.[bq]:null;
        if (Ry!=null) arrR.push({t,val:Ry});
        if (cell && Math.abs(cell.w)>1e-12) arrW.push({t,val:cell.w});
      });
      arrR.sort((a,b)=>b.val-a.val);
      arrW.sort((a,b)=>b.val-a.val);
      const mR={}; arrR.forEach((o,i)=>mR[o.t]={rank:i+1,total:arrR.length});
      const mW={}; arrW.forEach((o,i)=>mW[o.t]={rank:i+1,total:arrW.length});
      rankReturnYear[y]=mR; rankWeightYear[y]=mW;
    });
    return {rankReturnYear,rankWeightYear};
  }

  // ---------- Build summaries & summary ranks (new) ----------
  const summaryByTrack = new Map(); // t -> { full, cum, avgW }
  trackNames.forEach(t=>{
    summaryByTrack.set(t, computeSummariesForTrack(
      t, mode, years, activeQuartersByYear, periodR, annualR, agg
    ));
  });

  // Rank by cumulative return (desc) and avg weight (desc) â€” only full tracks
  const yieldUniverse = trackNames
    .map(t => ({ t, v: summaryByTrack.get(t).cum }))
    .filter(o => o.v != null)
    .sort((a,b)=> b.v - a.v);

  const weightUniverse = trackNames
    .map(t => ({ t, v: summaryByTrack.get(t).avgW }))
    .filter(o => o.v != null)
    .sort((a,b)=> b.v - a.v);

  const rankMapSumYield  = new Map();
  const rankMapSumWeight = new Map();
  yieldUniverse.forEach((o,i)=> rankMapSumYield.set(o.t,  {rank:i+1, total: yieldUniverse.length}));
  weightUniverse.forEach((o,i)=>rankMapSumWeight.set(o.t, {rank:i+1, total: weightUniverse.length}));

  // ---------- Table build ----------
  const thead = document.createElement("thead");
  const tbody = document.createElement("tbody");

  if (mode === "quarter") {
    titleEl.textContent = "××˜×¨×™×¦×ª ×©×™×¢×•×¨ ××¡×š ×”×ª×™×§, ×ª×©×•××”, ×“×™×¨×•×’×™× ×•×¡×™×›×•× â€“ ×œ×¤×™ ×¨×‘×¢×•×Ÿ";

    const tr1 = document.createElement("tr");
    const thTrack = thWith({text:"××¡×œ×•×œ", attrs:{rowspan:3}});
    tr1.appendChild(thTrack);

    // Summary headers (multiple)
    const summaryThs = [];
    summaryKeys.forEach(sk=>{
      const fld = SUMMARY_FIELDS.find(f=>f.key===sk);
      if (!fld) return;
      const th = thWith({text: fld.label, attrs:{rowspan:3}});
      makeSortable(th, { type:'summary', fieldKey: sk });
      summaryThs.push(th);
    });
    summaryThs.forEach(th => tr1.appendChild(th));

    years.forEach(y=>{
      const qs = (activeQuartersByYear.get(y)||[]);
      if (qs.length===0) return;
      tr1.appendChild(thWith({text:String(y), attrs:{colspan: qs.length * cellFields.length}}));
    });
    thead.appendChild(tr1);

    const tr2 = document.createElement("tr");
    years.forEach(y=>{
      (activeQuartersByYear.get(y)||[]).forEach(q=>{
        tr2.appendChild(thWith({text:`×¨×‘×¢×•×Ÿ ${q}`, attrs:{colspan: cellFields.length}}));
      });
    });
    thead.appendChild(tr2);

    const tr3 = document.createElement("tr");
    years.forEach(y=>{
      (activeQuartersByYear.get(y)||[]).forEach(q=>{
        cellFields.forEach(fld=>{
          const th = thWith({text: fld.label});
          makeSortable(th, { type:'cell', year:y, quarter:q, fieldKey:fld.key });
          tr3.appendChild(th);
        });
      });
    });
    thead.appendChild(tr3);

    clearHeaderCarets(thead);
    makeSortable(thTrack, { type:'track' });

    const {rankReturnMap,rankWeightMap} = buildRankMapsQuarter();

    // model for sorting
    const model = trackNames.map(t=>{
      const sum = summaryByTrack.get(t) || {full:false, cum:null, avgW:null};
      const rec = {
        track: t,
        values: {},
        sum_cum_return_num:  (sum.full && sum.cum  != null) ? (sum.cum  * 100) : null,
        sum_avg_weight_num:  (sum.full && sum.avgW != null) ? (sum.avgW * 100) : null,
        sum_rank_yield_num:  (sum.full && rankMapSumYield.get(t))  ? rankMapSumYield.get(t).rank  : null,
        sum_rank_weight_num: (sum.full && rankMapSumWeight.get(t)) ? rankMapSumWeight.get(t).rank : null
      };

      years.forEach(y=>{
        (activeQuartersByYear.get(y)||[]).forEach(q=>{
          const cell = agg?.[t]?.[y]?.[q] || null;
          const w = (cell && Math.abs(cell.w)>1e-9)? (cell.w*100) : null;
          const rq = periodR?.[t]?.[y]?.[q];
          const yv = (rq!=null) ? (rq*100) : null;
          const rRet = rankReturnMap[y]?.[q]?.[t] ? rankReturnMap[y][q][t].rank : null;
          const rWei = rankWeightMap[y]?.[q]?.[t] ? rankWeightMap[y][q][t].rank : null;

          rec.values[`w|${y}|${q}`]  = w;
          rec.values[`y|${y}|${q}`]  = yv;
          rec.values[`ry|${y}|${q}`] = rRet;
          rec.values[`rw|${y}|${q}`] = rWei;
        });
      });

      return rec;
    });

    if (state.sort){
      const s = state.sort;
      if (s.type==='track'){
        model.sort((a,b)=>compareValues(a.track,b.track,s.dir));
      } else if (s.type==='summary'){
        const mapKey = (s.fieldKey==='sum_cum_return'  ? 'sum_cum_return_num'
                      : s.fieldKey==='sum_avg_weight'  ? 'sum_avg_weight_num'
                      : s.fieldKey==='sum_rank_yield'  ? 'sum_rank_yield_num'
                      : s.fieldKey==='sum_rank_weight' ? 'sum_rank_weight_num'
                      : null);
        if (mapKey){
          model.sort((a,b)=>compareValues(a[mapKey], b[mapKey], s.dir));
        }
      } else if (s.type==='cell'){
        const key = (s.fieldKey==='weight' ? `w|${s.year}|${s.quarter}`
                   : s.fieldKey==='yield'  ? `y|${s.year}|${s.quarter}`
                   : s.fieldKey==='rank_yield'  ? `ry|${s.year}|${s.quarter}`
                   : /* rank_weight */           `rw|${s.year}|${s.quarter}`);
        model.sort((a,b)=>compareValues(a.values[key], b.values[key], s.dir));
      }
    }

    model.forEach(({track:t})=>{
      const tr = document.createElement("tr");
      if (rows.some(r=>r.track_name===t && String(r.company_short||"").includes("×× ×•×¨×”"))) tr.className = "row-menora";
      tr.appendChild(tdWith({html:`${t}`, cls:"matrix-row-header"}));

      // Summary cells (left side)
      summaryKeys.forEach(sk=>{
        const sum = summaryByTrack.get(t) || {full:false, cum:null, avgW:null};
        if (!sum.full){
          tr.appendChild(tdWith({html:'-'}));
          return;
        }
        if (sk === 'sum_cum_return'){
          tr.appendChild(tdWith({html: `<span class="num">${(sum.cum*100).toFixed(2)}%</span>`}));
        } else if (sk === 'sum_avg_weight'){
          tr.appendChild(tdWith({html: `<span class="num">${(sum.avgW*100).toFixed(2)}%</span>`}));
        } else if (sk === 'sum_rank_yield'){
          const r = rankMapSumYield.get(t);
          tr.appendChild(tdWith({text: r ? `${r.rank}/${r.total}` : '-'}));
        } else if (sk === 'sum_rank_weight'){
          const r = rankMapSumWeight.get(t);
          tr.appendChild(tdWith({text: r ? `${r.rank}/${r.total}` : '-'}));
        }
      });

      // Period cells
      years.forEach(y=>{
        (activeQuartersByYear.get(y)||[]).forEach(q=>{
          const cell=agg[t]?.[y]?.[q]||null;
          const wDisp = (cell && Math.abs(cell.w)>1e-9) ? (cell.w*100).toFixed(2)+"%" : "-";
          let yDisp="-", rRet="", rWei="";
          const rq = periodR?.[t]?.[y]?.[q];
          if (rq!=null) yDisp = (rq*100).toFixed(2)+"%";
          const infoR=rankReturnMap[y]?.[q]?.[t];
          const infoW=rankWeightMap[y]?.[q]?.[t];
          if (infoR && infoR.total>0) rRet=`${infoR.rank}/${infoR.total}`;
          if (infoW && infoW.total>0) rWei=`${infoW.rank}/${infoW.total}`;

          cellFields.forEach(fld=>{
            if (fld.key==="weight")            tr.appendChild(tdWith({html:`<span class="num">${wDisp}</span>`}));
            else if (fld.key==="yield")        tr.appendChild(tdWith({html:`<span class="num">${yDisp}</span>`}));
            else if (fld.key==="rank_yield")   tr.appendChild(tdWith({text:rRet}));
            else if (fld.key==="rank_weight")  tr.appendChild(tdWith({text:rWei}));
          });
        });
      });

      tbody.appendChild(tr);
    });

  } else {
    titleEl.textContent = "××˜×¨×™×¦×ª ×©×™×¢×•×¨ ××¡×š ×”×ª×™×§, ×ª×©×•××”, ×“×™×¨×•×’×™× ×•×¡×™×›×•× â€“ ×œ×¤×™ ×©× ×™×";

    const tr1 = document.createElement("tr");
    const thTrack = thWith({text:"××¡×œ×•×œ", attrs:{rowspan:2}});
    tr1.appendChild(thTrack);

    // Summary headers (multiple)
    const summaryThs = [];
    summaryKeys.forEach(sk=>{
      const fld = SUMMARY_FIELDS.find(f=>f.key===sk);
      if (!fld) return;
      const th = thWith({text: fld.label, attrs:{rowspan:2}});
      makeSortable(th, { type:'summary', fieldKey: sk });
      summaryThs.push(th);
    });
    summaryThs.forEach(th => tr1.appendChild(th));

    years.forEach(y=>{
      tr1.appendChild(thWith({text:String(y), attrs:{colspan: cellFields.length}}));
    });
    thead.appendChild(tr1);

    const tr2 = document.createElement("tr");
    years.forEach(y=>{
      cellFields.forEach(fld=>{
        const th = thWith({text: fld.label});
        makeSortable(th, { type:'cell', year:y, quarter:null, fieldKey:fld.key });
        tr2.appendChild(th);
      });
    });
    thead.appendChild(tr2);

    clearHeaderCarets(thead);
    makeSortable(thTrack, { type:'track' });

    const {rankReturnYear,rankWeightYear} = (function(){
      const rY={}, wY={};
      years.forEach(y=>{
        const arrR=[], arrW=[];
        trackNames.forEach(t=>{
          const Ry = annualR?.[t]?.[y];
          const bq=bestQuarterForYear(agg,t,y); const cell=bq? agg[t]?.[y]?.[bq]:null;
          if (Ry!=null) arrR.push({t,val:Ry});
          if (cell && Math.abs(cell.w)>1e-12) arrW.push({t,val:cell.w});
        });
        arrR.sort((a,b)=>b.val-a.val);
        arrW.sort((a,b)=>b.val-a.val);
        const mR={}; arrR.forEach((o,i)=>mR[o.t]={rank:i+1,total:arrR.length});
        const mW={}; arrW.forEach((o,i)=>mW[o.t]={rank:i+1,total:arrW.length});
        rY[y]=mR; wY[y]=mW;
      });
      return {rankReturnYear:rY,rankWeightYear:wY};
    })();

    const model = trackNames.map(t=>{
      const sum = summaryByTrack.get(t) || {full:false, cum:null, avgW:null};
      const rec = {
        track: t,
        values: {},
        sum_cum_return_num:  (sum.full && sum.cum  != null) ? (sum.cum  * 100) : null,
        sum_avg_weight_num:  (sum.full && sum.avgW != null) ? (sum.avgW * 100) : null,
        sum_rank_yield_num:  (sum.full && rankMapSumYield.get(t))  ? rankMapSumYield.get(t).rank  : null,
        sum_rank_weight_num: (sum.full && rankMapSumWeight.get(t)) ? rankMapSumWeight.get(t).rank : null
      };

      years.forEach(y=>{
        const bq=bestQuarterForYear(agg,t,y); const cell=bq? agg[t]?.[y]?.[bq]:null;
        const w = (cell && Math.abs(cell.w)>1e-9)? (cell.w*100) : null;
        const Ry = annualR?.[t]?.[y];
        const yv = (Ry!=null)? (Ry*100) : null;
        const rRet = rankReturnYear[y]?.[t] ? rankReturnYear[y][t].rank : null;
        const rWei = rankWeightYear[y]?.[t] ? rankWeightYear[y][t].rank : null;

        rec.values[`w|${y}`]  = w;
        rec.values[`y|${y}`]  = yv;
        rec.values[`ry|${y}`] = rRet;
        rec.values[`rw|${y}`] = rWei;
      });
      return rec;
    });

    if (state.sort){
      const s = state.sort;
      if (s.type==='track'){
        model.sort((a,b)=>compareValues(a.track,b.track,s.dir));
      } else if (s.type==='summary'){
        const mapKey = (s.fieldKey==='sum_cum_return'  ? 'sum_cum_return_num'
                      : s.fieldKey==='sum_avg_weight'  ? 'sum_avg_weight_num'
                      : s.fieldKey==='sum_rank_yield'  ? 'sum_rank_yield_num'
                      : s.fieldKey==='sum_rank_weight' ? 'sum_rank_weight_num'
                      : null);
        if (mapKey){
          model.sort((a,b)=>compareValues(a[mapKey], b[mapKey], s.dir));
        }
      } else if (s.type==='cell'){
        const key = (s.fieldKey==='weight' ? `w|${s.year}`
                   : s.fieldKey==='yield'  ? `y|${s.year}`
                   : s.fieldKey==='rank_yield'  ? `ry|${s.year}`
                   : /* rank_weight */           `rw|${s.year}`);
        model.sort((a,b)=>compareValues(a.values[key], b.values[key], s.dir));
      }
    }

    model.forEach(({track:t})=>{
      const tr = document.createElement("tr");
      if (rows.some(r=>r.track_name===t && String(r.company_short||"").includes("×× ×•×¨×”"))) tr.className = "row-menora";
      tr.appendChild(tdWith({html:`${t}`, cls:"matrix-row-header"}));

      // Summary cells (left side)
      summaryKeys.forEach(sk=>{
        const sum = summaryByTrack.get(t) || {full:false, cum:null, avgW:null};
        if (!sum.full){
          tr.appendChild(tdWith({html:'-'}));
          return;
        }
        if (sk === 'sum_cum_return'){
          tr.appendChild(tdWith({html: `<span class="num">${(sum.cum*100).toFixed(2)}%</span>`}));
        } else if (sk === 'sum_avg_weight'){
          tr.appendChild(tdWith({html: `<span class="num">${(sum.avgW*100).toFixed(2)}%</span>`}));
        } else if (sk === 'sum_rank_yield'){
          const r = rankMapSumYield.get(t);
          tr.appendChild(tdWith({text: r ? `${r.rank}/${r.total}` : '-'}));
        } else if (sk === 'sum_rank_weight'){
          const r = rankMapSumWeight.get(t);
          tr.appendChild(tdWith({text: r ? `${r.rank}/${r.total}` : '-'}));
        }
      });

      // Year cells
      years.forEach(y=>{
        const bq=bestQuarterForYear(agg,t,y); const cell=bq? agg[t]?.[y]?.[bq]:null;

        const wDisp = (cell && Math.abs(cell.w)>1e-9)? (cell.w*100).toFixed(2)+"%" : "-";
        const Ry = annualR?.[t]?.[y];
        const yDisp = (Ry!=null)? (Ry*100).toFixed(2)+"%" : "-";

        const RR=rankReturnYear[y]?.[t]; const RW=rankWeightYear[y]?.[t];
        const rRet = RR? `${RR.rank}/${RR.total}` : "";
        const rWei = RW? `${RW.rank}/${RW.total}` : "";

        cellFields.forEach(fld=>{
          if (fld.key==="weight")            tr.appendChild(tdWith({html:`<span class="num">${wDisp}</span>`}));
          else if (fld.key==="yield")        tr.appendChild(tdWith({html:`<span class="num">${yDisp}</span>`}));
          else if (fld.key==="rank_yield")   tr.appendChild(tdWith({text:rRet}));
          else if (fld.key==="rank_weight")  tr.appendChild(tdWith({text:rWei}));
        });
      });

      tbody.appendChild(tr);
    });
  }

  table.appendChild(thead);
  table.appendChild(tbody);
  table.style.tableLayout = "auto";
  table.style.width = "max-content";
  applyMatrixTableWidthMode();
}


/* CHARTS */
function rowsForLiquidityBase() {
  const f = getCurrentFilters();
  const rows = state.raw.filter(r=>Number(r.year)>=2022);
  return rows.filter(r=>{
    if (f.saving_type && r.saving_type !== f.saving_type) return false;
    if (f.fund_type   && r.fund_type   !== f.fund_type)   return false;
    if (Array.isArray(f.track) && f.track.length && !f.track.includes(r.track_name)) return false;
    if (Array.isArray(f.year) && f.year.length && !f.year.includes(String(r.year))) return false;
    return true;
  });
}
function toggleLiquidityQuarterVisibility() {
  const mode = document.getElementById("col_mode").value || "quarter";
  const qField = document.getElementById("liq_q_field");
  const title = document.getElementById("liq_chart_title");
  if (mode === "year") { qField.style.display = "none"; title.textContent = "××—×–×§×” ×œ×¤×™ ××¡×œ×•×œ ×•×¡×—×™×¨×•×ª (%) â€“ ×œ×¤×™ ×©× ×™× (×¨×‘×¢×•×Ÿ 4/3/2/1 ×œ×¤×™ ×–××™× ×•×ª)"; }
  else { qField.style.display = ""; title.textContent = "××—×–×§×” ×œ×¤×™ ××¡×œ×•×œ ×•×¡×—×™×¨×•×ª (%)"; }
}

/* For charts ordering by current sort â€“ now fed by PERIOD returns map */
function bestQuarterForSeries(seriesObj, year){
  for (const q of [4,3,2,1]) {
    const key = `${year}|${q}`;
    if (seriesObj && (seriesObj[key]!=null)) return key;
  }
  return null;
}
function orderedKeysByCurrentSort(keys, rSeries, seriesWeight){
  const s = state.sort;
  if (!s || s.type!=='cell') return keys.slice();
  if (s.fieldKey!=='yield' && s.fieldKey!=='weight') return keys.slice();

  const dir = s.dir || 'desc';
  const withVal = keys.map(name=>{
    let periodKey = null;
    if (s.quarter==null){
      periodKey = bestQuarterForSeries(rSeries[name], s.year);
    } else {
      periodKey = `${s.year}|${s.quarter}`;
    }
    let val = null;
    if (s.fieldKey==='yield'){
      const rq = rSeries[name]?.[periodKey];
      if (rq!=null) val = rq*100;
    } else if (s.fieldKey==='weight'){
      const w = seriesWeight[name]?.[periodKey];
      if (w!=null) val = w * 100;
    }
    return {name, val};
  });

  withVal.sort((a,b)=>compareValues(a.val, b.val, dir));
  return withVal.map(x=>x.name);
}

/* Build per-series period returns from cumulative R=c/w */
function buildSeriesMaps(rows){
  const seriesKey = (r)=>{
    const c = r.company_short || "×œ× ×™×“×•×¢";
    const t = r.track_name || "";
    return t ? `${c} â€“ ${t}` : c;
  };
  const seriesCum = {};   // cumulative: {name: { "Y|Q": {w,c} }}
  const seriesW   = {};   // weight only: {name: { "Y|Q": w }}
  rows.forEach(r=>{
    if (!r.year || !r.quarter) return;
    const tk = `${r.year}|${r.quarter}`;
    const sk = seriesKey(r);
    const wAll = nz(r.weight);
    const cAll = nz(r.contribution);

    if (!seriesCum[sk]) seriesCum[sk]={};
    if (!seriesCum[sk][tk]) seriesCum[sk][tk]={w:0,c:0};
    seriesCum[sk][tk].w += wAll;
    seriesCum[sk][tk].c += cAll;

    if (!seriesW[sk]) seriesW[sk]={};
    if (!seriesW[sk][tk]) seriesW[sk][tk]=0;
    seriesW[sk][tk] += wAll;
  });

  // derive per-period r for each series across time ascending
  const rSeries = {}; // {name:{ "Y|Q": r }}
  Object.keys(seriesCum).forEach(name=>{
    const keys = Object.keys(seriesCum[name]).sort((a,b)=>{
      const [ya,qa]=a.split("|").map(Number); const [yb,qb]=b.split("|").map(Number);
      return ya===yb? qa-qb : ya-yb;
    });
    rSeries[name]={};
    let prevR = null;
    keys.forEach(k=>{
      const cell = seriesCum[name][k];
      const Rq = (cell && Math.abs(cell.w)>1e-12) ? (cell.c/cell.w) : null;
      let rq = null;
      if (Rq==null) rq=null;
      else if (prevR==null) rq = Rq;
      else rq = (1+Rq)/(1+prevR) - 1;
      rSeries[name][k] = rq;
      prevR = Rq;
    });
  });

  return { seriesCum, seriesW, rSeries };
}

function refreshLiquidityFilters() {
  const selYear = document.getElementById("liq_year_filter");
  const selQuarter = document.getElementById("liq_quarter_filter");
  if (!selYear || !selQuarter) return;

  const mode = document.getElementById("col_mode").value || "quarter";
  const rows = rowsForLiquidityBase().filter(r => r.year && r.quarter);
  if (!rows.length) { selYear.innerHTML=""; selQuarter.innerHTML=""; return; }

  const yearsArr = Array.from(new Set(rows.map(r=>Number(r.year)))).sort((a,b)=>a-b);
  const prevYear = selYear.value, prevQuarter = selQuarter.value;
  const defaultYear = yearsArr[yearsArr.length - 1];

  selYear.innerHTML = "";
  const fragYear = document.createDocumentFragment();
  yearsArr.forEach(y=>{ const o=document.createElement("option"); o.value=String(y); o.textContent=String(y); fragYear.appendChild(o); });
  selYear.appendChild(fragYear);
  selYear.value = yearsArr.includes(Number(prevYear)) ? prevYear : String(defaultYear);

  if (mode === "quarter") {
    const quartersArr = Array.from(new Set(rows.filter(r=>Number(r.year)===Number(selYear.value)).map(r=>Number(r.quarter)))).sort((a,b)=>a-b);
    selQuarter.innerHTML = "";
    const fragQ = document.createDocumentFragment();
    quartersArr.forEach(q=>{ const o=document.createElement("option"); o.value=String(q); o.textContent=String(q); fragQ.appendChild(o); });
    selQuarter.appendChild(fragQ);
    const defaultQuarter = quartersArr[quartersArr.length - 1];
    selQuarter.value = quartersArr.includes(Number(prevQuarter)) ? prevQuarter : String(defaultQuarter);
  } else {
    selQuarter.innerHTML = "";
  }
}

function renderCharts() {
  const rows = state.filtered;

  if (state.chartYield)  { state.chartYield.destroy();  state.chartYield=null; }
  if (state.chartWeight) { state.chartWeight.destroy(); state.chartWeight=null; }
  if (!rows.length) {
    if (state.chartLiquidity) { state.chartLiquidity.destroy(); state.chartLiquidity = null; }
    return;
  }

  // Build series maps
  const { seriesCum, seriesW, rSeries } = buildSeriesMaps(rows);

  const timeSet = new Set();
  rows.forEach(r=>{ if (r.year && r.quarter) timeSet.add(r.year+"|"+r.quarter); });
  const timeKeys = Array.from(timeSet).sort((a,b)=>{
    const [ya,qa]=a.split("|").map(Number);
    const [yb,qb]=b.split("|").map(Number);
    return ya===yb ? qa-qb : ya-yb;
  });
  const labels = timeKeys.map(k=>{ const [y,q]=k.split("|"); return y+" Q"+q; });

  const palette = ["#53d3ff","#ffb74d","#81c784","#ba68c8","#ff8a65","#4db6ac","#ce93d8","#f06292","#ffd54f","#7986cb","#90caf9","#a5d6a7","#ffe082","#ffab91","#b39ddb"];
  let keys = Object.keys(seriesCum);

  // Order datasets by current sort (yield uses rSeries, weight uses seriesW)
  keys = orderedKeysByCurrentSort(keys, rSeries, seriesW);

  const datasetsYield = keys.map((name,i)=>{
    const color=palette[i%palette.length];
    const data=timeKeys.map(k=>{
      const rq = rSeries[name]?.[k];
      return (rq==null)? null : (rq*100);
    });
    return { label:name, data, type:"bar", backgroundColor:color+"cc", borderColor:color, borderWidth:1, skipNull:true };
  });

  const datasetsWeight = keys.map((name,i)=>{
    const color=palette[i%palette.length];
    const data=timeKeys.map(k=>{
      const w = seriesW[name]?.[k];
      if (w==null) return null;
      return w*100;
    });
    return { label:name, data, type:"bar", backgroundColor:color+"cc", borderColor:color, borderWidth:1, skipNull:true };
  });

  const ctxYield  = document.getElementById("chart_yield").getContext("2d");
  const ctxWeight = document.getElementById("chart_weight").getContext("2d");

  const opt=(title)=>({
    responsive:true,
    maintainAspectRatio:false,
    interaction:{ mode:"index", intersect:false },
    plugins:{
      legend:{ position:"bottom", labels:{ color:"#e9eefb", font:{size:11} } },
      tooltip:{ callbacks:{ label:(c)=>`${c.dataset.label}: ${c.parsed.y?.toFixed(2)||0}%` } }
    },
    scales:{
      x:{ ticks:{color:"#a6b2c9"}, grid:{color:"rgba(255,255,255,0.06)"} },
      y:{ ticks:{color:"#a6b2c9", callback:v=>v.toFixed(1)+"%"},
          grid:{color:"rgba(255,255,255,0.04)"},
          title:{display:true,text:title,color:"#e9eefb"} }
    }
  });

  state.chartYield  = new Chart(ctxYield, { type:"bar", data:{labels,datasets:datasetsYield},  options:opt("×ª×©×•××” ×¨×‘×¢×•× ×™×ª ××¤×•×¨×§×ª (%)") });
  state.chartWeight = new Chart(ctxWeight,{ type:"bar", data:{labels,datasets:datasetsWeight}, options:opt("××—×–×§×” ×¨×‘×¢×•× ×™×ª ×××•×¦×¢×ª ×œ×ª×¦×•×’×” (%)") });

  renderLiquidityChart();
}

/* BOTTOM CHART */
function renderLiquidityChart() {
  const canvas = document.getElementById("chart_liquidity");
  if (!canvas) return;
  const ctxLiquidity = canvas.getContext("2d");
  if (state.chartLiquidity) { state.chartLiquidity.destroy(); state.chartLiquidity = null; }

  const selYear = document.getElementById("liq_year_filter");
  const selQuarter = document.getElementById("liq_quarter_filter");
  const mode = document.getElementById("col_mode").value || "quarter";
  if (!selYear || !selYear.value) return;
  if (mode==="quarter" && (!selQuarter || !selQuarter.value)) return;

  const yearSel = selYear.value;
  const quarterSel = selQuarter?.value;

  // ×‘×¡×™×¡ ×”× ×ª×•× ×™× ×œ×’×¨×£ ×”×¡×—×™×¨×•×ª (×©×•××¨ ×¢×œ ×¡×™× ×•×Ÿ ×‘×¨××ª ×”×“×©×‘×•×¨×“, ××‘×œ ×‘×œ×™ ×¡×™× ×•×Ÿ "×¡×—×™×¨×•×ª")
  const baseRows = rowsForLiquidityBase();

  // ×‘×—×™×¨×ª ×¨×©×•××•×ª ×œ×¤×™ ××¦×‘ "×¨×‘×¢×•×Ÿ" ××• "×©× ×™×" (×‘×©× ×™× â€“ × ×œ×§×— ×”×¨×‘×¢×•×Ÿ ×”××—×¨×•×Ÿ ×”×–××™×Ÿ ×œ×›×œ ××¡×œ×•×œ)
  let rows = [];
  if (mode==="quarter") {
    rows = baseRows.filter(r => String(r.year) === yearSel && String(r.quarter) === quarterSel);
  } else {
    const rowsYear = baseRows.filter(r => String(r.year)===yearSel && r.quarter);
    // ×××ª×¨×™× ×œ×›×œ ××¡×œ×•×œ ××ª ×”×¨×‘×¢×•×Ÿ ×”××—×¨×•×Ÿ ×”×–××™×Ÿ ×‘×©× ×”
    const latestByTrack = new Map();
    rowsYear.forEach(r=>{
      const t=r.track_name; const q=Number(r.quarter);
      if (!t) return;
      if (!latestByTrack.has(t) || q > latestByTrack.get(t)) latestByTrack.set(t, q);
    });
    rows = rowsYear.filter(r => latestByTrack.get(r.track_name) === Number(r.quarter));
  }

  if (!rows.length) return;

  // ××•×¡×£ ××¡×œ×•×œ×™×
  const trackSet = new Set();
  rows.forEach(r => { if (r.track_name) trackSet.add(r.track_name); });
  let tracks = Array.from(trackSet);

  // ××™×•×Ÿ ×”××¡×œ×•×œ×™× ×œ×¤×™ ××™×•×Ÿ ×¤×¢×™×œ ×‘×˜×‘×œ×” (×× ×™×©), ××—×¨×ª ××œ×¤×‘×™×ª×™
  const s = state.sort;
  if (s && s.type==='cell' && (s.fieldKey==='weight' || s.fieldKey==='yield')) {
    const dir = s.dir || 'desc';
    const scoreByTrack = new Map();
    const yTarget = s.year;
    const qTarget = s.quarter==null ? null : Number(s.quarter);

    tracks.forEach(t=>{
      let relevant = [];
      if (qTarget==null){
        // ×× ×”××™×•×Ÿ ×”×•× "×œ×¤×™ ×©× ×”" â€“ ×§×— ××ª ×”×¨×‘×¢×•×Ÿ ×”××—×¨×•×Ÿ ×”×–××™×Ÿ ×œ××•×ª×” ×©× ×”
        for (const q of [4,3,2,1]) {
          const subset = rows.filter(r=>r.track_name===t && Number(r.year)===Number(yTarget) && Number(r.quarter)===q);
          if (subset.length){ relevant = subset; break; }
        }
      } else {
        relevant = rows.filter(r=>r.track_name===t && Number(r.year)===Number(yTarget) && Number(r.quarter)===qTarget);
      }
      let val = null;
      if (relevant.length){
        if (s.fieldKey==='weight'){
          const w = relevant.reduce((acc,r)=>acc + nz(r.weight), 0);
          val = w*100;
        } else if (s.fieldKey==='yield'){
          // ×”×¢×¨×›×ª ×ª×©×•××” ×¨×‘×¢×•× ×™×ª ××××’×¨ ××¦×˜×‘×¨ (contribution/weight) â€“ ×›××• ×‘×™×ª×¨ ×”×§×•×“
          const aggTmp = {};
          relevant.forEach(r=>{
            const y=Number(r.year), q=Number(r.quarter);
            const w=nz(r.weight), c=nz(r.contribution);
            if (!aggTmp[y]) aggTmp[y]={};
            if (!aggTmp[y][q]) aggTmp[y][q]={w:0,c:0};
            aggTmp[y][q].w+=w; aggTmp[y][q].c+=c;
          });
          let prevR=null; let rq=null;
          const qList = Object.keys(aggTmp[Number(yTarget)]||{}).map(Number).sort((a,b)=>a-b);
          qList.forEach(q=>{
            const cell=aggTmp[Number(yTarget)][q];
            const Rq=(cell && Math.abs(cell.w)>1e-12)? (cell.c/cell.w):null;
            if (Rq!=null){
              if (prevR==null) rq=Rq; else rq=(1+Rq)/(1+prevR)-1;
              prevR=Rq;
            }
          });
          if (rq!=null) val = rq*100;
        }
      }
      scoreByTrack.set(t, val);
    });
    tracks.sort((a,b)=>{
      const av = scoreByTrack.get(a), bv = scoreByTrack.get(b);
      return compareValues(av, bv, dir);
    });
  } else {
    tracks.sort((a,b)=>String(a).localeCompare(String(b),"he"));
  }

  // ×—×™×©×•×‘ ××©×§×œ×™× "×¡×—×™×¨" ×•"×œ× ×¡×—×™×¨" ×œ×›×œ ××¡×œ×•×œ
  const liqByTrack = new Map(tracks.map(t => [t, { liquid: 0, illiquid: 0 }]));
  rows.forEach(r=>{
    const t = r.track_name;
    const w = nz(r.weight);
    if (!liqByTrack.has(t)) liqByTrack.set(t, { liquid: 0, illiquid: 0 });
    if (r.liquidity === "×¡×—×™×¨") liqByTrack.get(t).liquid  += w;
    else                        liqByTrack.get(t).illiquid += w;
  });

  // ×‘× ×™×™×ª ×©× ×™ ××§×˜×¢×™× ×¨×¦×™×¤×™×: ×§×•×“× ×¡×—×™×¨×™× ×œ×›×œ ×”××¡×œ×•×œ×™×, ××—×¨ ×›×š ×œ×-×¡×—×™×¨×™× ×œ×›×œ ×”××¡×œ×•×œ×™×
  const labels = [
    ...tracks.map(t => `${t} â€¢ ×¡×—×™×¨`),
    ...tracks.map(t => `${t} â€¢ ×œ× ×¡×—×™×¨`)
  ];

  const data = [
    ...tracks.map(t => (liqByTrack.get(t)?.liquid  ?? 0) * 100),
    ...tracks.map(t => (liqByTrack.get(t)?.illiquid ?? 0) * 100)
  ];

  const splitIndex = tracks.length; // × ×§×•×“×ª ×”××¢×‘×¨ ×‘×™×Ÿ ×”××§×˜×¢×™×

  const options = {
    responsive:true,
    maintainAspectRatio:false,
    interaction:{ mode:"index", intersect:false },
    plugins:{
      legend:{ display:false },
      tooltip:{
        callbacks:{
          label:(c)=>{
            const idx = c.dataIndex;
            const type = idx < splitIndex ? "×¡×—×™×¨" : "×œ× ×¡×—×™×¨";
            const track = idx < splitIndex ? tracks[idx] : tracks[idx - splitIndex];
            const val = (c.parsed.y ?? 0).toFixed(2);
            return `${track} â€“ ${type}: ${val}%`;
          }
        }
      },
      // ×§×• ××¤×¨×™×“ ×•×ª×™×•×’ ×”××§×˜×¢×™×
      annotation: undefined
    },
    elements: { bar: { maxBarThickness: 28, barPercentage: 0.9, categoryPercentage: 0.7 } },
    scales:{
      x:{
        ticks:{ color:"#a6b2c9" },
        grid:{ color:"rgba(255,255,255,0.06)" },
        title:{ display:true, text:"××¡×œ×•×œ (×¡×—×™×¨ â†’ ×œ× ×¡×—×™×¨)", color:"#e9eefb" }
      },
      y:{
        ticks:{ color:"#a6b2c9", callback:v=>v.toFixed(1)+"%" },
        grid:{ color:"rgba(255,255,255,0.04)" },
        title:{ display:true, text:"××—×–×§×” ××”×ª×™×§ (%)", color:"#e9eefb" }
      }
    },
    layout: { padding: { left: 8, right: 8 } }
  };

  // ×¦×‘×¢ ×œ×¤×™ ××§×˜×¢: ×¡×—×™×¨ (×›×—×•×œ) ×•××– ×œ×-×¡×—×™×¨ (×›×ª×•×)
  const dataset = {
    label: "××—×–×§×” ××”×ª×™×§ (%)",
    data,
    type: "bar",
    borderWidth: 1,
    borderColor: (ctx) => (ctx.dataIndex < splitIndex ? "#53d3ff" : "#ffb74d"),
    backgroundColor: (ctx) => (ctx.dataIndex < splitIndex ? "#53d3ff" : "#ffb74d")
  };

  // ×›×•×ª×¨×ª ×’×¨×£ ××¢×•×“×›× ×ª
  const titleEl = document.getElementById("liq_chart_title");
  if (mode === "year") {
    titleEl.textContent = "××—×–×§×” ×œ×¤×™ ××¡×œ×•×œ â€“ ×¡×—×™×¨ (×›×•×œ×) ×•××– ×œ×-×¡×—×™×¨ (×›×•×œ×) â€“ ×œ×¤×™ ×©× ×™× (×¨×‘×¢×•×Ÿ ××—×¨×•×Ÿ ×–××™×Ÿ)";
  } else {
    titleEl.textContent = "××—×–×§×” ×œ×¤×™ ××¡×œ×•×œ â€“ ×§×•×“× ×¡×—×™×¨ ×œ×›×œ ×”××¡×œ×•×œ×™×, ××—×¨×™×• ×œ×-×¡×—×™×¨ ×œ×›×œ ×”××¡×œ×•×œ×™×";
  }

  state.chartLiquidity = new Chart(ctxLiquidity,{
    type: "bar",
    data: { labels, datasets: [dataset] },
    options
  });
}


/* INIT */
document.getElementById("btn_reload").addEventListener("click", reloadData);

reloadData();
renderCharts();
</script>

</body>
</html>
